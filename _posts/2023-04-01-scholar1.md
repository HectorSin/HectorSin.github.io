---
layout: posts
title: "논문스터디-NIPS-2012-imagenet-classification"
categories: 논문
tag: [ML, Study]
toc: true
---

# 논문 정리
***
## 논문 요약

이 논문은 대규모 이미지 데이터셋인 ImageNet에서 이미지 분류 문제를 해결하기 위해 딥러닝 모델을 개발한 것을 다룹니다. 저자들은 ILSVRC-2010 및 ILSVRC-2012 대회에서 사용된 ImageNet 하위 데이터셋에서 가장 큰 컨볼루션 신경망 중 하나를 학습시켰으며, 이 모델은 이전까지 보고된 결과보다 훨씬 우수한 성능을 보였습니다. 이를 위해 저자들은 비 포화 뉴런과 GPU 구현 등의 기술을 사용하여 학습 속도를 높였으며, 과적합 문제를 해결하기 위해 Dropout이라는 정규화 방법을 적용했습니다. 이 모델은 ILSVRC-2012 대회에서 15.3%의 최상위 5개 오류율을 달성하여 우승하였습니다.

## 서론 분석

서론에서는 딥러닝 모델이 이미지 분류 문제를 해결하는 데 있어서 매우 효과적인 방법임을 언급하고, 이전 연구들에서 사용된 모델들의 한계점을 지적합니다. 그리고 이에 대한 대안으로 컨볼루션 신경망을 제안하며, 이 모델이 이미지 분류 문제를 해결하는 데 있어서 매우 유용하다는 것을 강조합니다. 또한, 이 모델이 기존 모델보다 우수한 성능을 보인 이유와 그 결과로 얻어진 인사이트에 대해서도 언급합니다. 

이 모델이 기존 모델보다 우수한 성능을 보인 이유는 여러 가지가 있습니다. 첫째, 이 모델은 더 깊고 큰 규모의 신경망을 사용하였습니다. 이를 통해 더 복잡한 패턴을 학습할 수 있었으며, 이전 모델에서 발생했던 문제점들을 해결할 수 있었습니다. 둘째, 비 포화 뉴런과 GPU 구현 등의 기술을 사용하여 학습 속도를 높였습니다. 셋째, 과적합 문제를 해결하기 위해 Dropout이라는 정규화 방법을 적용하였습니다.

이 모델로부터 얻어진 인사이트는 다음과 같습니다. 첫째, 딥러닝 모델은 이미지 분류 문제에서 매우 효과적인 방법임을 입증하였습니다. 둘째, 컨볼루션 신경망은 이미지 분류 문제를 해결하는 데 있어서 매우 유용한 모델임을 보여주었습니다. 셋째, 비 포화 뉴런과 Dropout 등의 기술은 딥러닝 모델의 성능 향상에 매우 중요한 역할을 할 수 있다는 것입니다. 넷째, GPU를 이용한 병렬 처리는 딥러닝 모델의 학습 속도를 크게 향상시킬 수 있다는 것입니다. 이러한 인사이트들은 딥러닝 분야에서의 연구와 응용에 큰 도움을 줄 수 있습니다.

마지막으로, 본 논문에서 다루게 될 내용과 기여도에 대해 위 요약의 글처럼 간략히 설명하며, 독자들이 본 논문의 내용을 잘 파악할 수 있도록 서론을 구성하고 있습니다.

## 방법론 분석

여기서 제안된 방법론은 딥러닝 모델 중 하나인 컨볼루션 신경망을 사용하여 이미지 분류 문제를 해결하는 것입니다. 이 모델은 ILSVRC-2010 및 ILSVRC-2012 대회에서 사용된 ImageNet 하위 데이터셋에서 가장 큰 컨볼루션 신경망 중 하나로, 학습 속도를 높이기 위해 비 포화 뉴런과 GPU 구현 등의 기술을 사용하였습니다.

이 모델은 5개의 컨볼루션 레이어와 3개의 fully-connected 레이어로 구성되어 있으며, 마지막 레이어는 1000-way softmax 함수를 사용하여 이미지를 1000개의 클래스 중 하나로 분류합니다. 이 모델은 매우 깊고 큰 규모의 신경망으로, 이전 모델들보다 훨씬 복잡한 패턴을 학습할 수 있습니다.

또한, 이 모델에서는 비 포화 뉴런과 Dropout 등의 기술을 사용하여 과적합 문제를 해결하였습니다. 비 포화 뉴런은 입력값이 일정 값 이상일 때 출력값이 증가하지 않는 활성화 함수로, 학습 속도를 향상시키는 효과가 있습니다. Dropout은 학습 과정에서 무작위로 일부 뉴런을 제거하여 과적합을 방지하는 정규화 방법입니다.

또한, 두 개의 GPU를 사용하여 컨볼루션 신경망을 학습하였으며, 이를 통해 학습 시간을 대폭 줄일 수 있었습니다. 또한, 현재의 GPU들은 서로 다른 GPU 간에 데이터 전송이 가능하기 때문에, 병렬 처리 과정에서 발생하는 데이터 전송 시간 문제도 해결할 수 있습니다.

## 실험 결과 분석

ImageNet 데이터셋을 사용하여 딥러닝 모델의 성능을 평가하였습니다. 실험 결과, 이 모델은 최상위 5개 오류율이 15.3%로, 이전까지 보고된 결과보다 훨씬 우수한 성능을 보여주었습니다. 또한, 이 모델은 ILSVRC-2012 대회에서 우승하였습니다.

이러한 결과는 딥러닝 분야에서의 연구와 응용에 큰 영향을 미치게 되며, 특히 이미지 분류 문제를 해결하는 데 있어서 매우 유용한 모델임을 입증하였습니다. 실험 결과를 통해 볼 때, 이 모델은 매우 깊고 큰 규모의 신경망으로, 이전 모델들보다 훨씬 복잡한 패턴을 학습할 수 있었습니다. 또한, 비 포화 뉴런과 Dropout 등의 기술을 사용하여 과적합 문제를 해결하였으며, GPU를 이용한 병렬 처리를 사용하여 학습 속도를 높였습니다.

따라서, 이러한 실험 결과는 딥러닝 분야에서의 연구와 응용에 큰 기여를 할 것으로 기대됩니다.

## 논문 평가

본 논문은 딥러닝 분야에서 가장 기본적이면서도 중요한 논문 중 하나입니다. 이 논문에서 제안된 딥러닝 모델은 ImageNet 데이터셋을 사용하여 이미지 분류 문제를 해결하는 데 있어서 매우 우수한 성능을 보여주었습니다. 이 모델은 매우 깊고 큰 규모의 신경망으로, 이전 모델들보다 훨씬 복잡한 패턴을 학습할 수 있습니다.

또한, 이 논문에서는 비 포화 뉴런과 Dropout 등의 기술을 사용하여 과적합 문제를 해결하였으며, GPU를 이용한 병렬 처리를 사용하여 학습 속도를 높였습니다. 이러한 방법론들은 딥러닝 모델의 성능을 크게 향상시키는 데 기여하였습니다.

따라서, 본 논문은 딥러닝 분야에서의 연구와 응용에 큰 영향을 미치게 되며, 특히 이미지 분류 문제를 해결하는 데 있어서 매우 유용한 모델임을 입증하였습니다. 이러한 배경으로 본 논문은 딥러닝 분야에 관심이 있는 사람들에게 매우 유용한 논문 중 하나입니다.

## 결론 분석

본 연구에서 제안된 딥러닝 모델은 이미지 분류 문제를 해결하는 데 있어서 매우 우수한 성능을 보여주었습니다. 이러한 모델은 컴퓨터 비전 분야에서 매우 유용하게 사용될 수 있습니다. 예를 들어, 자율 주행 자동차나 로봇 등의 기계 학습 분야에서 이미지 인식 문제를 해결하는 데 사용될 수 있습니다.

또한, 이 모델이 진행한 대회인 ILSVRC-2012 대회는 이미지 인식 분야에서 가장 중요한 대회 중 하나입니다. 이 대회는 매년 열리며, 최신 기술을 사용하여 이미지 인식 문제를 해결하는 데 도전합니다. 본 연구에서 제안된 딥러닝 모델은 이 대회에서 우승하였으며, 이는 딥러닝 분야에서의 연구와 응용에 큰 영향을 미치게 되었습니다.

따라서, 본 연구는 컴퓨터 비전 분야 및 기계 학습 분야에서 매우 유용하게 사용될 수 있으며, 이미지 인식 문제를 해결하는 데 큰 역할을 할 것으로 기대됩니다.

# 관련 기술, 대회 분석
***
## ILSVRC-2010
[대회 설명]
ILSVRC-2010는 ImageNet Large Scale Visual Recognition Challenge 2010의 약어로, 2010년에 개최된 이미지 인식 대회입니다. ILSVRC는 영상 인식 분야에서 가장 유명한 대회 중 하나로, 이미지 인식 및 객체 인식 분야에서 모델의 성능을 평가하는 데 사용됩니다. ILSVRC-2010은 ImageNet 데이터셋을 기반으로 하며, 이 대회에서는 22,000개 이상의 이미지와 1,000개의 클래스로 이루어진 데이터셋을 사용했습니다. 대회의 목표는 컴퓨터 비전 분야에서 모델의 성능을 향상시키기 위한 연구를 촉진하는 것입니다. 이후 ILSVRC 대회는 매년 열리고 있으며, 최근에는 ILSVRC 대회의 성능 향상에 따라 다양한 응용 분야에서 활용되고 있습니다.

역대 우승 알고리즘은 다음과 같다
* 2010 - NEC-UIUC (Lin et al.)
* 2011 - XRCE (Florent Perronnin, Jorge Sanchez) 
* 2012 - AlexNet
* 2013 - ZFNet
* 2014 - 우승 GoogLeNet, 준우승 VGGNet (VGGNet이 준우승을 하긴 했지만, 구조의 간결함과 사용의 편이성으로 인해 GoogLeNet보다 더 각광받았다.)
* 2015 - ResNet
* 2016 - GoogLeNet-v4
* 2017 - SENet
[[출처]-ILSVRC 대회 역대 우승 알고리즘들](https://bskyvision.com/entry/ILSVRC-%EB%8C%80%ED%9A%8C-%EC%9D%B4%EB%AF%B8%EC%A7%80%EB%84%B7-%EC%9D%B4%EB%AF%B8%EC%A7%80-%EC%9D%B8%EC%8B%9D-%EB%8C%80%ED%9A%8C-%EC%97%AD%EB%8C%80-%EC%9A%B0%EC%8A%B9-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98%EB%93%A4)

## AlexNet

AlexNet의 기본구조는 LeNet-5와 크게 다르지 않다. 2개의 GPU로 병렬연산을 수행하기 위해서 병렬적인 구조로 설계되었다는 점이 가장 큰 변화이다.

![img](https://t1.daumcdn.net/cfile/tistory/99FEB93C5C80B5192E)

AlexNet은 8개의 레이어로 구성되어 있다. 5개의 컨볼루션 레이어와 3개의 full-connected 레이어로 구성되어 있다. 두번째, 네번째, 다섯번째 컨볼루션 레이어들은 전 단계의 같은 채널의 특성맵들과만 연결되어 있는 반면, 세번째 컨볼루션 레이어는 전 단계의 두 채널의 특성맵들과 모두 연결되어 있다는 것을 집고 넘어가자. 

이제 각 레이어마다 어떤 작업이 수행되는지 살펴보자. 우선 AlexNet에 입력 되는 것은 227 x 227 x 3 이미지다. (227 x 227 사이즈의 RGB 컬러 이미지를 뜻한다.) 그림에는 224로 되어 있는데 잘못된 겁니다. 

1) 첫번째 레이어(컨볼루션 레이어): 96개의 11 x 11 x 3 사이즈 필터커널로 입력 영상을 컨볼루션해준다. 컨볼루션 보폭(stride)를 4로 설정했고, zero-padding은 사용하지 않았다. zero-padding은 컨볼루션으로 인해 특성맵의 사이즈가 축소되는 것을 방지하기 위해, 또는 축소되는 정도를 줄이기 위해 영상의 가장자리 부분에 0을 추가하는 것이다. 결과적으로 55 x 55 x 96 특성맵(96장의 55 x 55 사이즈 특성맵들)이 산출된다. 그 다음에 ReLU 함수로 활성화해준다. 이어서 3 x 3 overlapping max pooling이 stride 2로 시행된다. 그 결과 27 x 27 x 96 특성맵을 갖게 된다. 그 다음에는 수렴 속도를 높이기 위해 local response normalization이 시행된다. local response normalization은 특성맵의 차원을 변화시키지 않으므로, 특성맵의 크기는 27 x 27 x 96으로 유지된다. 

* 컨볼루션 이후 특성맵의 사이즈가 어떻게 결정되는지에 대해서 의문을 가질 분들이 계실 것 같습니다. 그래서 이에 대한 내용을 AlexNet보다 이후에 나온 모델들인 VGG-F, VGG-M, VGG-S을 설명하면서 하단부에 소개했으니 참고하시기 바랍니다.
=> [https://bskyvision.com/420](https://bskyvision.com/420)

2) 두번째 레이어(컨볼루션 레이어): 256개의 5 x 5 x 48 커널을 사용하여 전 단계의 특성맵을 컨볼루션해준다. stride는 1로, zero-padding은 2로 설정했다. 따라서 27 x 27 x 256 특성맵(256장의 27 x 27 사이즈 특성맵들)을 얻게 된다. 역시 ReLU 함수로 활성화한다. 그 다음에 3 x 3 overlapping max pooling을 stride 2로 시행한다. 그 결과 13 x 13 x 256 특성맵을 얻게 된다. 그 후 local response normalization이 시행되고, 특성맵의 크기는 13 x 13 x 256으로 그대로 유지된다. 

3) 세번째 레이어(컨볼루션 레이어): 384개의 3 x 3 x 256 커널을 사용하여 전 단계의 특성맵을 컨볼루션해준다. stride와 zero-padding 모두 1로 설정한다. 따라서 13 x 13 x 384 특성맵(384장의 13 x 13 사이즈 특성맵들)을 얻게 된다. 역시 ReLU 함수로 활성화한다. 

4) 네번째 레이어(컨볼루션 레이어): 384개의 3 x 3 x 192 커널을 사용해서 전 단계의 특성맵을 컨볼루션해준다. stride와 zero-padding 모두 1로 설정한다. 따라서 13 x 13 x 384 특성맵(384장의 13 x 13 사이즈 특성맵들)을 얻게 된다. 역시 ReLU 함수로 활성화한다. 

5) 다섯번째 레이어(컨볼루션 레이어): 256개의 3 x 3 x 192 커널을 사용해서 전 단계의 특성맵을 컨볼루션해준다. stride와 zero-padding 모두 1로 설정한다. 따라서 13 x 13 x 256 특성맵(256장의 13 x 13 사이즈 특성맵들)을 얻게 된다. 역시 ReLU 함수로 활성화한다. 그 다음에 3 x 3 overlapping max pooling을 stride 2로 시행한다. 그 결과 6 x 6 x 256 특성맵을 얻게 된다. 

6) 여섯번째 레이어(Fully connected layer): 6 x 6 x 256 특성맵을 flatten해줘서 6 x 6 x 256 = 9216차원의 벡터로 만들어준다. 그것을 여섯번째 레이어의 4096개의 뉴런과 fully connected 해준다. 그 결과를 ReLU 함수로 활성화한다. 

7) 일곱번째 레이어(Fully connected layer): 4096개의 뉴런으로 구성되어 있다. 전 단계의 4096개 뉴런과 fully connected되어 있다. 출력 값은 ReLU 함수로 활성화된다. 

8) 여덟번째 레이어(Fully connected layer): 1000개의 뉴런으로 구성되어 있다. 전 단계의 4096개 뉴런과 fully connected되어 있다. 1000개 뉴런의 출력값에 softmax 함수를 적용해 1000개 클래스 각각에 속할 확률을 나타낸다. 

총, 약 6천만개의 파라미터가 훈련되어야 한다. LeNet-5에서 6만개의 파라미터가 훈련되야했던 것과 비교하면 천배나 많아졌다. 하지만 그만큼 컴퓨팅 기술도 좋아졌고, 훈련시간을 줄이기 위한 방법들도 사용되었기 때문에 훈련이 가능했다. 예전 기술 같으면 상상도 못할 연산량이다. 


[출처]-[CNN 알고리즘들 AlexNet의 구조](https://bskyvision.com/421)

# 참조 논문 분석
***